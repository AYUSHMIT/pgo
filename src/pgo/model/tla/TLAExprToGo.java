package pgo.model.tla;

import java.util.Vector;

import pgo.model.golang.*;
import pgo.model.intermediate.PGoCollectionType;
import pgo.model.intermediate.PGoCollectionType.PGoSet;
import pgo.model.intermediate.PGoPrimitiveType.PGoDecimal;
import pgo.model.intermediate.PGoPrimitiveType.PGoNatural;
import pgo.model.intermediate.PGoPrimitiveType.PGoNumber;
import pgo.model.intermediate.PGoType;
import pgo.model.intermediate.PGoVariable;
import pgo.trans.PGoTransException;
import pgo.trans.intermediate.PGoTempData;

/**
 * Converts the TLA ast generated by the TLAExprParser into GoAST
 *
 */
public class TLAExprToGo {
	// the resulting GoAST expression
	private Expression expr;
	// the inferred type of the expression
	private PGoType type;
	// the Go program's imports
	private Imports imports;
	// the intermediate data; includes information about the type of variables
	private PGoTempData data;

/*	public TLAExprToGo(Vector<PGoTLA> tla, Imports imports, PGoTempData data) throws PGoTransException {
		stmts = new Vector<>();
		this.imports = imports;
		this.data = data;
		convert(tla);
	}*/

	public TLAExprToGo(PGoTLA tla, Imports imports, PGoTempData data) throws PGoTransException {
		this.imports = imports;
		this.data = data;
		type = new TLAExprToType(tla, data).getType();
		expr = tla.convert(this);
	}

	public PGoType getType() {
		return type;
	}

	public Expression toExpression() {
		return expr;
	}

	/**
	 * Takes PGoTLA ast tree and converts it to Go statement
	 * 
	 * TODO probably want to take the tokens into a class TLAExprToGo. Then
	 * support things like getEquivStatement() to get the equivalent go expr to
	 * refer to the equivalent data in the pluscal, and getInit() to get any
	 * initialization code to generate that data. Constructor of this class may
	 * need to know what local variable names are available
	 * 
	 * @param ptla
	 * @throws PGoTransException
	 *             if there is a typing inconsistency
	 */
/*	private void convert(Vector<PGoTLA> ptla) throws PGoTransException {
		for (PGoTLA tla : ptla) {
			// check type consistency
			new TLAExprToType(tla, data);
			expr.addAll(tla.convert(this));
		}
	}*/

	/**
	 * Convert the TLA expression to a Go AST, while also adding the correct
	 * imports.
	 * 
	 * @param tla
	 *            the TLA expression
	 */
	protected Expression translate(PGoTLAArray tla) {
		// TODO (issue #5, 23)
		return new SimpleExpression(new Vector<>());
	}

	protected Expression translate(PGoTLABool tla) {
		return new Token(String.valueOf(tla.getVal()));
	}

	protected Expression translate(PGoTLABoolOp tla) throws PGoTransException {
		Expression leftRes = tla.getLeft().convert(this);
		Expression rightRes = tla.getRight().convert(this);

		// we have already checked types for consistency, so can check just lhs
		PGoType leftType = new TLAExprToType(tla.getLeft(), data).getType();
		if (leftType instanceof PGoSet) {
			imports.addImport("mapset");
			Vector<Expression> leftExp = new Vector<>();
			leftExp.add(leftRes);

			switch (tla.getToken()) {
			case "#":
			case "/=":
				Vector<Expression> toks = new Vector<>();
				toks.add(new Token("!"));
				toks.add(new FunctionCall("Equal", leftExp, rightRes));
				return new SimpleExpression(toks);
			case "=":
			case "==":
				return new FunctionCall("Equal", leftExp, rightRes);
			default:
				assert false;
				return null;
			}
		}

		String tok = tla.getToken();
		switch (tok) {
		case "#":
		case "/=":
			tok = "!=";
			break;
		case "/\\":
		case "\\land":
			tok = "&&";
			break;
		case "\\/":
		case "\\lor":
			tok = "||";
			break;
		case "=<":
		case "\\leq":
			tok = "<=";
			break;
		case "\\geq":
			tok = ">=";
			break;
		case "=":
			tok = "==";
			break;
		}

		// if we are comparing number types we may need to do type conversion
		if (leftType instanceof PGoNumber) {
			PGoType rightType = new TLAExprToType(tla.getRight(), data).getType();
			PGoType convertedType = TLAExprToType.compatibleType(leftType, rightType);
			assert (convertedType != null);
			// cast if not plain number
			if (!leftType.equals(convertedType) && !(tla.getLeft() instanceof PGoTLANumber)) {
				leftRes = new TypeConversion(convertedType, leftRes);
			} else if (!rightType.equals(convertedType) && !(tla.getRight() instanceof PGoTLANumber)) {
				// only one of the left or right needs to be cast
				rightRes = new TypeConversion(convertedType, rightRes);
			}
		}

		Vector<Expression> toks = new Vector<Expression>();
		toks.add(leftRes);
		toks.add(new Token(" " + tok + " "));
		toks.add(rightRes);

		return new SimpleExpression(toks);
	}

	protected Expression translate(PGoTLAFunction tla) {
		// TODO (issue #23)
		return new SimpleExpression(new Vector<>());
	}

	protected Expression translate(PGoTLAGroup tla) throws PGoTransException {
		Expression inside = tla.getInner().convert(this);
		return new Group(inside);
	}

	protected Expression translate(PGoTLANumber tla) {
		return new Token(tla.getVal());
	}

	protected Expression translate(PGoTLASequence tla) throws PGoTransException {
		Expression startRes = tla.getStart().convert(this);
		Expression endRes = tla.getEnd().convert(this);

		Vector<Expression> args = new Vector<>();
		// we may need to convert natural to int
		PGoType startType = new TLAExprToType(tla.getStart(), data).getType();
		PGoType endType = new TLAExprToType(tla.getEnd(), data).getType();
		// plain numbers are never naturals (int or float only), so we don't
		// need to check if the exprs are plain numbers
		if (startType instanceof PGoNatural) {
			startRes = new TypeConversion("int", startRes);
		}
		if (endType instanceof PGoNatural) {
			endRes = new TypeConversion("int", endRes);
		}
		args.add(startRes);
		args.add(endRes);

		this.imports.addImport("pgoutil");
		return new FunctionCall("pgoutil.Sequence", args);
	}

	protected Expression translate(PGoTLASet tla) throws PGoTransException {
		Vector<Expression> args = new Vector<>();
		for (PGoTLA ptla : tla.getContents()) {
			args.add(ptla.convert(this));
		}
		this.imports.addImport("mapset");
		return new FunctionCall("mapset.NewSet", args);
	}

	protected Expression translate(PGoTLASetOp tla) throws PGoTransException {
		Expression leftRes = tla.getLeft().convert(this);
		Expression rightRes = tla.getRight().convert(this);

		Vector<Expression> lhs = new Vector<>();
		lhs.add(leftRes);

		Vector<Expression> exp = new Vector<>();
		String funcName = null;
		// Map the set operation to the mapset function. \\notin does not have a
		// corresponding function and is handled separately.
		switch (tla.getToken()) {
		case "\\cup":
		case "\\union":
			funcName = "Union";
			break;
		case "\\cap":
		case "\\intersect":
			funcName = "Intersect";
			break;
		case "\\in":
			funcName = "Contains";
			break;
		case "\\notin":
			funcName = "NotIn";
			break;
		case "\\subseteq":
			funcName = "IsSubset";
			break;
		case "\\":
			funcName = "Difference";
			break;
		default:
			assert false;
		}

		if (funcName.equals("NotIn")) {
			exp.add(new Token("!"));
			funcName = "Contains";
		}
		// rightRes is the object because lhs can be an element (e.g. in
		// Contains)
		this.imports.addImport("mapset");
		exp.add(new FunctionCall(funcName, lhs, rightRes));
		return new SimpleExpression(exp);
	}

	protected Expression translate(PGoTLASimpleArithmetic tla) throws PGoTransException {
		Expression leftRes = tla.getLeft().convert(this);
		Expression rightRes = tla.getRight().convert(this);
		PGoType leftType = new TLAExprToType(tla.getLeft(), data).getType();
		PGoType rightType = new TLAExprToType(tla.getRight(), data).getType();
		
		if (tla.getToken().equals("^")) {
			this.imports.addImport("math");
			Vector<Expression> params = new Vector<>();
			// math.Pow takes float64s; convert if needed
			if (!(tla.getLeft() instanceof PGoTLANumber || leftType instanceof PGoDecimal)) {
				leftRes = new TypeConversion("float64", leftRes);
			}
			if (!(tla.getRight() instanceof PGoTLANumber || rightType instanceof PGoDecimal)) {
				rightRes = new TypeConversion("float64", rightRes);
			}
			params.add(leftRes);
			params.add(rightRes);
			return new FunctionCall("math.Pow", params);
		} else {
			PGoType convertedType = TLAExprToType.compatibleType(leftType, rightType);
			assert (convertedType != null);
			if (!(tla.getLeft() instanceof PGoTLANumber || leftType.equals(convertedType))) {
				leftRes = new TypeConversion(convertedType, leftRes);
			} else if (!(tla.getRight() instanceof PGoTLANumber || rightType.equals(convertedType))) {
				rightRes = new TypeConversion(convertedType, rightRes);
			}
			
			Vector<Expression> toks = new Vector<>();
			toks.add(leftRes);
			toks.add(new Token(" " + tla.getToken() + " "));
			toks.add(rightRes);
			return new SimpleExpression(toks);
		}
	}

	protected Expression translate(PGoTLAString tla) {
		return new Token(tla.getString());
	}

	protected Expression translate(PGoTLAUnary tla) throws PGoTransException {
		Vector<Statement> ret = new Vector<>();

		switch (tla.getToken()) {
		case "~":
		case "\\lnot":
		case "\\neg":
			Expression expr = tla.getArg().convert(this);
			Vector<Expression> exp = new Vector<>();
			exp.add(new Token("!"));
			exp.add(expr);
			return new SimpleExpression(exp);
		case "UNION":
			expr = tla.getArg().convert(this);
			FunctionCall fc = new FunctionCall("pgoutil.EltUnion", new Vector<Expression>() {
				{
					add(expr);
				}
			});
			this.imports.addImport("pgoutil");
			return fc;
		case "SUBSET":
			expr = tla.getArg().convert(this);
			FunctionCall fc1 = new FunctionCall("PowerSet", new Vector<>(), expr);
			this.imports.addImport("mapset");
			return fc1;
		// these operations are of the form OP x \in S : P(x)
		case "CHOOSE":
			PGoTLASuchThat st = (PGoTLASuchThat) tla.getArg();
			assert (st.getSets().size() == 1);
			// the set S
			Expression setExpr = st.getSets().get(0).getRight().convert(this);
			// the variable x
			Expression varExpr = st.getSets().get(0).getLeft().convert(this);
			// We need to add typing data to avoid TLAExprToType complaining
			// about untyped variables
			PGoTempData temp = new PGoTempData(data);
			for (PGoTLASetOp set : st.getSets()) {
				// TODO handle stuff like << x, y >> \in S \X T
				assert (set.getLeft() instanceof PGoTLAVariable);
				PGoTLAVariable var = (PGoTLAVariable) set.getLeft();
				PGoType containerType = new TLAExprToType(set.getRight(), data).getType();
				assert (containerType instanceof PGoSet);
				PGoType eltType = ((PGoSet) containerType).getElementType();
				temp.getLocals().put(var.getName(), PGoVariable.convert(var.getName(), eltType));
			}
			Expression pred = new TLAExprToGo(st.getExpr(), imports, temp).toExpression();
			// most expressions can't be used as the variable (only stuff like
			// tuples) so this should be one line
			assert (varExpr.toGo().size() == 1);

			// create the anonymous function for the predicate
			// go func: Choose(P interface{}, S mapset.Set) interface{}
			// (P is predicate)
			// P = func(varType) bool { return pred }
			AnonymousFunction P = new AnonymousFunction(PGoType.inferFromGoTypeName("bool"),
					// TODO (issue 28) deal with tuples as variable declaration
					new Vector<ParameterDeclaration>() {
						{
							add(new ParameterDeclaration(varExpr.toGo().get(0),
									new TLAExprToType(tla, data).getType()));
						}
					},
					new Vector<>(),
					new Vector<Statement>() {
						{
							add(new Return(pred));
						}
					});

			Vector<Expression> chooseFuncParams = new Vector<>();
			chooseFuncParams.add(P);
			chooseFuncParams.add(setExpr);

			this.imports.addImport("pgoutil");
			return new FunctionCall("pgoutil.Choose", chooseFuncParams);
		case "\\E":
		case "\\A":
			st = (PGoTLASuchThat) tla.getArg();

			temp = new PGoTempData(data);
			for (PGoTLASetOp set : st.getSets()) {
				// TODO handle stuff like << x, y >> \in S \X T
				assert (set.getLeft() instanceof PGoTLAVariable);
				PGoTLAVariable var = (PGoTLAVariable) set.getLeft();
				PGoType containerType = new TLAExprToType(set.getRight(), data).getType();
				assert (containerType instanceof PGoSet);
				PGoType eltType = ((PGoSet) containerType).getElementType();
				temp.getLocals().put(var.getName(), PGoVariable.convert(var.getName(), eltType));
			}
			pred = new TLAExprToGo(st.getExpr(), imports, temp).toExpression();

			Vector<Expression> setExprs = new Vector<>(), varExprs = new Vector<>();
			for (PGoTLASetOp setOp : st.getSets()) {
				varExprs.add(setOp.getLeft().convert(this));
				setExprs.add(setOp.getRight().convert(this));
			}
			// create the anonymous function for the predicate
			// go func: Exists|ForAll(P interface{}, S ...mapset.Set) interface{}
			// (P is predicate)
			// P = func(varType, varType...) bool { return pred }
			P = new AnonymousFunction(PGoType.inferFromGoTypeName("bool"),
					// TODO (issue 28) deal with tuples as variable declaration
					new Vector<ParameterDeclaration>() {
						{
							// var[i] \in set[i]
							for (int i = 0; i < setExprs.size(); i++) {
								PGoType setType = new TLAExprToType(st.getSets().get(i).getRight(), data)
										.getType();
								PGoType varType = ((PGoCollectionType) setType).getElementType();
								add(new ParameterDeclaration(varExprs.get(i).toGo().get(0),
										varType));
							}
						}
					},
					new Vector<>(),
					new Vector<Statement>() {
						{
							add(new Return(pred));
						}
					});

			Vector<Expression> funcParams = new Vector<>();
			funcParams.add(P);
			for (Expression s : setExprs) {
				funcParams.add(s);
			}

			this.imports.addImport("pgoutil");
			return new FunctionCall((tla.getToken().equals("\\E") ? "pgoutil.Exists" : "pgoutil.ForAll"),
					funcParams);
		}
		assert false;
		return null;
	}

	protected Expression translate(PGoTLAVariable tla) {
		return new Token(String.valueOf(tla.getName()));
	}

	protected Expression translate(PGoTLASuchThat tla) {
		// This compiles differently based on context, so we should deal with
		// translating this when we have the appropriate context.
		assert false;
		return null;
	}
}
