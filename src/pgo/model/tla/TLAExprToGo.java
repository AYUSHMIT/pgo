package pgo.model.tla;

import java.util.HashSet;
import java.util.Set;
import java.util.Vector;

import pgo.model.golang.Expression;
import pgo.model.golang.FunctionCall;
import pgo.model.golang.Group;
import pgo.model.golang.Imports;
import pgo.model.golang.ParameterDeclaration;
import pgo.model.golang.Return;
import pgo.model.golang.SimpleExpression;
import pgo.model.golang.Statement;
import pgo.model.golang.Token;
import pgo.model.intermediate.PGoType;

/**
 * Converts the TLA ast generated by the TLAExprParser into GoAST
 *
 */
public class TLAExprToGo {

	private Vector<Statement> stmts;
	// the Go program's imports
	private Imports imports;

	public TLAExprToGo(Vector<PGoTLA> tla, Imports imports) {
		stmts = new Vector<>();
		this.imports = imports;
		convert(tla);
	}

	public TLAExprToGo(PGoTLA tla, Imports imports) {
		this.imports = imports;
		stmts = convert(tla);
	}

	public SimpleExpression toSimpleExpression() {
		// TODO Auto-generated method stub
		return null;
	}

	public Vector<Statement> getStatements() {
		return stmts;
	}

	/**
	 * Takes PGoTLA ast tree and converts it to Go statement
	 * 
	 * TODO probably want to take the tokens into a class TLAExprToGo. Then
	 * support things like getEquivStatement() to get the equivalent go expr to
	 * refer to the equivalent data in the pluscal, and getInit() to get any
	 * initialization code to generate that data. Constructor of this class may
	 * need to know what local variable names are available
	 * 
	 * @param ptla
	 * @return
	 */
	private void convert(Vector<PGoTLA> ptla) {
		for (PGoTLA tla : ptla) {
			stmts.addAll(tla.convert(this));
		}
	}

	private Vector<Statement> convert(PGoTLA tla) {
		return tla.convert(this);
	}

	/**
	 * Convert the TLA expression to a Go AST, while also adding the correct
	 * imports.
	 * 
	 * @param tla
	 *            the TLA expression
	 */
	protected Vector<Statement> translate(PGoTLA tla) {
		// shouldn't pass in raw PGoTLA
		assert false;
		return null;
	}

	protected Vector<Statement> translate(PGoTLAArray tla) {
		// TODO (issue #5, 23)
		return new Vector<>();
	}

	protected Vector<Statement> translate(PGoTLABool tla) {
		Vector<Statement> ret = new Vector<>();
		ret.add(new Token(String.valueOf(tla.getVal())));
		return ret;
	}

	protected Vector<Statement> translate(PGoTLABoolOp tla) {
		// TODO (issue #22) we need to see whether we are operating on sets
		Vector<Statement> ret = new Vector<>();

		Vector<Statement> leftRes = convert(tla.getLeft());
		Vector<Statement> rightRes = convert(tla.getRight());

		// comparators operations should just be a single SimpleExpression
		assert (leftRes.size() == 1);
		assert (rightRes.size() == 1);
		assert (leftRes.get(0) instanceof Expression);
		assert (rightRes.get(0) instanceof Expression);

		String tok = tla.getToken();
		switch (tok) {
		case "#":
		case "/=":
			tok = "!=";
			break;
		case "/\\":
		case "\\land":
			tok = "&&";
			break;
		case "\\/":
		case "\\lor":
			tok = "||";
			break;
		case "=<":
		case "\\leq":
			tok = "<=";
			break;
		case "\\geq":
			tok = ">=";
			break;
		case "=":
			tok = "==";
			break;
		}

		Vector<Expression> toks = new Vector<Expression>();
		toks.add((Expression) leftRes.get(0));
		toks.add(new Token(" " + tok + " "));
		toks.add((Expression) rightRes.get(0));

		ret.add(new SimpleExpression(toks));
		return ret;
	}

	protected Vector<Statement> translate(PGoTLAFunction tla) {
		// TODO (issue #23)
		return new Vector<>();
	}

	protected Vector<Statement> translate(PGoTLAGroup tla) {
		Vector<Statement> ret = new Vector<>();

		Vector<Statement> inside = convert(tla.getInner());

		assert (inside.size() == 1);
		assert (inside.get(0) instanceof Expression);

		ret.add(new Group((Expression) inside.get(0)));

		return ret;
	}

	protected Vector<Statement> translate(PGoTLANumber tla) {
		Vector<Statement> ret = new Vector<>();
		ret.add(new Token(tla.getVal()));
		return ret;
	}

	protected Vector<Statement> translate(PGoTLASequence tla) {
		Vector<Statement> ret = new Vector<>();

		Vector<Statement> startRes = convert(tla.getStart());
		Vector<Statement> endRes = convert(tla.getEnd());

		// comparators operations should just be a single Expression
		assert (startRes.size() == 1);
		assert (endRes.size() == 1);
		assert (startRes.get(0) instanceof Expression);
		assert (endRes.get(0) instanceof Expression);

		Vector<Expression> args = new Vector<Expression>();
		args.add((Expression) startRes.get(0));
		args.add((Expression) endRes.get(0));

		FunctionCall fc = new FunctionCall("pgoutil.Sequence", args);
		ret.add(fc);

		this.imports.addImport("pgoutil");
		return ret;
	}

	protected Vector<Statement> translate(PGoTLASet tla) {
		Vector<Statement> ret = new Vector<>();

		Vector<Statement> contents = new Vector<>();
		for (PGoTLA ptla : tla.getContents()) {
			contents.addAll(convert(ptla));
		}

		Vector<Expression> args = new Vector<>();
		for (Statement s : contents) {
			assert (s instanceof Expression);
			args.add((Expression) s);
		}

		FunctionCall fc = new FunctionCall("mapset.NewSet", args);
		ret.addElement(fc);
		
		this.imports.addImport("mapset");
		return ret;
	}

	protected Vector<Statement> translate(PGoTLASetOp tla) {
		Vector<Statement> ret = new Vector<>();

		Vector<Statement> leftRes = convert(tla.getLeft());
		Vector<Statement> rightRes = convert(tla.getRight());

		// lhs and rhs should each be a single Expression
		assert (leftRes.size() == 1);
		assert (rightRes.size() == 1);
		assert (leftRes.get(0) instanceof Expression);
		assert (rightRes.get(0) instanceof Expression);

		Vector<Expression> lhs = new Vector<>();
		lhs.add((Expression) leftRes.get(0));
		Expression rightSet = (Expression) rightRes.get(0);

		Vector<Expression> exp = new Vector<>();
		String funcName = null;
		// Map the set operation to the mapset function. \\notin does not have a
		// corresponding function and is handled separately. Such that is a
		// completely different operation: if we are calling toStatements(), it
		// is used for set constructor/set image declaration of a set. The case
		// where such that is used in predicate operations is completely handled
		// by PGoTLAUnary.
		switch (tla.getToken()) {
		case "\\cup":
		case "\\union":
			funcName = "Union";
			break;
		case "\\cap":
		case "\\intersect":
			funcName = "Intersect";
			break;
		case "\\in":
			funcName = "Contains";
			break;
		case "\\notin":
			funcName = "NotIn";
			break;
		case "\\subseteq":
			funcName = "IsSubset";
			break;
		case "\\":
			funcName = "Difference";
			break;
		case ":":
			// TODO
		default:
			assert false;
		}

		if (funcName.equals("NotIn")) {
			exp.add(new Token("!"));
			funcName = "Contains";
		}
		// rightSet is the object because lhs can be an element (e.g. in
		// Contains)
		FunctionCall fc = new FunctionCall(funcName, lhs, rightSet);
		exp.add(fc);
		ret.add(new SimpleExpression(exp));
		this.imports.addImport("mapset");
		return ret;
	}

	protected Vector<Statement> translate(PGoTLASimpleArithmetic tla) {
		Vector<Statement> ret = new Vector<>();

		Vector<Statement> leftRes = convert(tla.getLeft());
		Vector<Statement> rightRes = convert(tla.getRight());

		// arithmetic operations should just be a single SimpleExpression
		assert (leftRes.size() == 1);
		assert (rightRes.size() == 1);
		assert (leftRes.get(0) instanceof Expression);
		assert (rightRes.get(0) instanceof Expression);

		if (tla.getToken().equals("^")) {
			// TODO (issue #22) we need to check which number type we are using and cast to/from
			// float64 if needed
			this.imports.addImport("math");
			Vector<Expression> params = new Vector<>();
			params.add((Expression) leftRes.get(0));
			params.add((Expression) rightRes.get(0));
			FunctionCall fc = new FunctionCall("math.Pow", params);
			ret.add(fc);
		} else {
			Vector<Expression> toks = new Vector<Expression>();
			toks.add((Expression) leftRes.get(0));

			toks.add(new Token(" " + tla.getToken() + " "));
			toks.add((Expression) rightRes.get(0));

			ret.add(new SimpleExpression(toks));
		}
		return ret;
	}

	protected Vector<Statement> translate(PGoTLAString tla) {
		Vector<Statement> ret = new Vector<>();
		ret.add(new Token(tla.getString()));
		return ret;
	}

	protected Vector<Statement> translate(PGoTLAUnary tla) {
		Vector<Statement> ret = new Vector<>();

		Vector<Statement> rightRes = convert(tla.getArg());
		// the argument should be a single Expression
		assert (rightRes.size() == 1);
		assert (rightRes.get(0) instanceof Expression);

		switch (tla.getToken()) {
		case "~":
		case "\\lnot":
		case "\\neg":
			Vector<Expression> exp = new Vector<>();
			exp.add(new Token("!"));
			exp.add((Expression) rightRes.get(0));
			ret.add(new SimpleExpression(exp));
			break;
		case "UNION":
			Vector<Statement> stmts = convert(tla.getArg());
			assert (stmts.size() == 1);
			assert (stmts.get(0) instanceof Expression);
			FunctionCall fc = new FunctionCall("pgoutil.EltUnion", new Vector<Expression>() {
				{
					add((Expression) stmts.get(0));
				}
			});
			this.imports.addImport("pgoutil");
			ret.add(fc);
			break;
		case "SUBSET":
			FunctionCall fc1 = new FunctionCall("PowerSet", new Vector<>(), (Expression) rightRes.get(0));
			this.imports.addImport("mapset");
			ret.add(fc1);
			break;
		// these operations are of the form OP x \in S : P(x)
		case "CHOOSE":
			// TODO
			assert (tla.getArg() instanceof PGoTLASetOp);
			PGoTLASetOp st = (PGoTLASetOp) tla.getArg();
			assert (st.getLeft() instanceof PGoTLASetOp); // this is the \in
			// the set S
			Vector<Statement> lr = convert(((PGoTLASetOp) st.getLeft()).getRight());
			// the variable x
			Vector<Statement> ll = convert(((PGoTLASetOp) st.getLeft()).getLeft());
			Vector<Statement> pred = convert(st.getRight());

			assert (ll.size() == 1);
			assert (ll.get(0) instanceof Token);
			Token varName = (Token) ll.get(0);

			// create the anonymous function for the predicate
			Vector<ParameterDeclaration> params = new Vector<>();
			params.add(new ParameterDeclaration(varName.getTokens(), PGoType.inferFromGoTypeName("interface{}")));
			Vector<Statement> body = new Vector<>();
			// since there are no complex assignments, the predicate should be a
			// single Expression
			assert (pred.size() == 1);
			assert (pred.get(0) instanceof Expression);
			body.add(new Return((Expression) pred.get(0)));
			
			this.imports.addImport("pgoutil");
		}
		return ret;
	}

	protected Vector<Statement> translate(PGoTLAVariable tla) {
		Vector<Statement> ret = new Vector<>();
		ret.add(new Token(String.valueOf(tla.getName())));
		return ret;
	}
}
